// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// Control-flow Graph

// structures
struct BinaryTree
{
  struct BinaryTree_vtable *vptr;
};
struct BT
{
  struct BT_vtable *vptr;
};
struct Tree
{
  struct Tree_vtable *vptr;
  struct Tree * left;
  struct Tree * right;
  int key;
  int has_left;
  int has_right;
  struct Tree * my_null;
};
// vtables structures
struct BinaryTree_vtable
{
};

struct BT_vtable
{
  int (*Start)();
};

struct Tree_vtable
{
  int (*Init)();
  int (*SetRight)();
  int (*SetLeft)();
  struct Tree * (*GetRight)();
  struct Tree * (*GetLeft)();
  int (*GetKey)();
  int (*SetKey)();
  int (*GetHas_Right)();
  int (*GetHas_Left)();
  int (*SetHas_Left)();
  int (*SetHas_Right)();
  int (*Compare)();
  int (*Insert)();
  int (*Delete)();
  int (*Remove)();
  int (*RemoveRight)();
  int (*RemoveLeft)();
  int (*Search)();
  int (*Print)();
  int (*RecPrint)();
};


// vtables declared
struct BinaryTree_vtable BinaryTree_vtable_ ;
struct BT_vtable BT_vtable_ ;
struct Tree_vtable Tree_vtable_ ;

// methods
int BT_Start(struct BT * this)
{
  struct Tree * root;
  int ntb;
  int nti;
  struct Tree * x_1;
  struct Tree * x_2;
  struct Tree * x_3;
  struct Tree * x_4;
  struct Tree * x_5;
  struct Tree * x_6;
  struct Tree * x_7;
  struct Tree * x_8;
  struct Tree * x_9;
  struct Tree * x_10;
  struct Tree * x_11;
  struct Tree * x_12;
  struct Tree * x_13;
  struct Tree * x_14;
  struct Tree * x_15;
  struct Tree * x_16;
  struct Tree * x_17;
  struct Tree * x_18;
  struct Tree * x_19;
  struct Tree * x_78;
  int x_79;
  int x_80;
  int x_81;
  int x_82;
  int x_83;
  int x_84;
  int x_85;
  int x_86;
  int x_87;
  int x_88;
  int x_89;
  int x_90;
  int x_91;
  int x_92;
  int x_93;
  int x_94;
  int x_95;
  int x_96;
  int x_97;

L_0:
  x_78 = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  root = x_78;
  x_79 = root->vptr->Init(root, 16);
  ntb = x_79;
  x_80 = root->vptr->Print(root);
  ntb = x_80;
  System_out_println (100000000);
  x_81 = root->vptr->Insert(root, 8);
  ntb = x_81;
  x_82 = root->vptr->Print(root);
  ntb = x_82;
  x_83 = root->vptr->Insert(root, 24);
  ntb = x_83;
  x_84 = root->vptr->Insert(root, 4);
  ntb = x_84;
  x_85 = root->vptr->Insert(root, 12);
  ntb = x_85;
  x_86 = root->vptr->Insert(root, 20);
  ntb = x_86;
  x_87 = root->vptr->Insert(root, 28);
  ntb = x_87;
  x_88 = root->vptr->Insert(root, 14);
  ntb = x_88;
  x_89 = root->vptr->Print(root);
  ntb = x_89;
  x_90 = root->vptr->Search(root, 24);
  System_out_println (x_90);
  x_91 = root->vptr->Search(root, 12);
  System_out_println (x_91);
  x_92 = root->vptr->Search(root, 16);
  System_out_println (x_92);
  x_93 = root->vptr->Search(root, 50);
  System_out_println (x_93);
  x_94 = root->vptr->Search(root, 12);
  System_out_println (x_94);
  x_95 = root->vptr->Delete(root, 12);
  ntb = x_95;
  x_96 = root->vptr->Print(root);
  ntb = x_96;
  x_97 = root->vptr->Search(root, 12);
  System_out_println (x_97);
  return 0;
}
int Tree_Init(struct Tree * this, int v_key)
{

L_1:
  this->key = v_key;
  this->has_left = 0;
  this->has_right = 0;
  return 1;
}
int Tree_SetRight(struct Tree * this, struct Tree * rn)
{

L_2:
  this->right = rn;
  return 1;
}
int Tree_SetLeft(struct Tree * this, struct Tree * ln)
{

L_3:
  this->left = ln;
  return 1;
}
struct Tree * Tree_GetRight(struct Tree * this)
{

L_4:
  return this->right;
}
struct Tree * Tree_GetLeft(struct Tree * this)
{

L_5:
  return this->left;
}
int Tree_GetKey(struct Tree * this)
{

L_6:
  return this->key;
}
int Tree_SetKey(struct Tree * this, int v_key)
{

L_7:
  this->key = v_key;
  return 1;
}
int Tree_GetHas_Right(struct Tree * this)
{

L_8:
  return this->has_right;
}
int Tree_GetHas_Left(struct Tree * this)
{

L_9:
  return this->has_left;
}
int Tree_SetHas_Left(struct Tree * this, int val)
{

L_10:
  this->has_left = val;
  return 1;
}
int Tree_SetHas_Right(struct Tree * this, int val)
{

L_11:
  this->has_right = val;
  return 1;
}
int Tree_Compare(struct Tree * this, int num1, int num2)
{
  int ntb;
  int nti;
  int x_98;
  int x_99;
  int x_100;
  int x_101;

L_12:
  ntb = 0;
  x_98 = num2 + 1;
  nti = x_98;
  x_99 = num1 < num2;
  if (x_99)
    goto L_13;
  else
    goto L_14;
L_14:
  x_101 = num1 < nti;
  x_100 = !(x_101);
  if (x_100)
    goto L_16;
  else
    goto L_17;
L_17:
  ntb = 1;
  goto L_18;
L_16:
  ntb = 0;
  goto L_18;
L_18:
  goto L_15;
L_13:
  ntb = 0;
  goto L_15;
L_15:
  return ntb;
}
int Tree_Insert(struct Tree * this, int v_key)
{
  struct Tree * new_node;
  int ntb;
  int cont;
  int key_aux;
  struct Tree * current_node;
  struct Tree * x_20;
  struct Tree * x_21;
  struct Tree * x_22;
  struct Tree * x_23;
  struct Tree * x_24;
  struct Tree * x_25;
  struct Tree * x_26;
  struct Tree * x_27;
  struct Tree * x_28;
  struct Tree * x_29;
  struct Tree * x_102;
  int x_103;
  int x_104;
  int x_105;
  int x_106;
  int x_107;
  int x_108;
  struct Tree * x_109;
  int x_110;
  int x_111;
  int x_112;
  struct Tree * x_113;

L_19:
  x_102 = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  new_node = x_102;
  x_103 = new_node->vptr->Init(new_node, v_key);
  ntb = x_103;
  current_node = this;
  cont = 1;
  goto L_20;
L_20:
  if (cont)
    goto L_21;
  else
    goto L_22;
L_21:
  x_104 = current_node->vptr->GetKey(current_node);
  key_aux = x_104;
  x_105 = v_key < key_aux;
  if (x_105)
    goto L_23;
  else
    goto L_24;
L_24:
  x_106 = current_node->vptr->GetHas_Right(current_node);
  if (x_106)
    goto L_26;
  else
    goto L_27;
L_27:
  cont = 0;
  x_107 = current_node->vptr->SetHas_Right(current_node, 1);
  ntb = x_107;
  x_108 = current_node->vptr->SetRight(current_node, new_node);
  ntb = x_108;

  goto L_28;
L_26:
  x_109 = current_node->vptr->GetRight(current_node);
  current_node = x_109;
  goto L_28;
L_28:

  goto L_25;
L_23:
  x_110 = current_node->vptr->GetHas_Left(current_node);
  if (x_110)
    goto L_29;
  else
    goto L_30;
L_30:
  cont = 0;
  x_111 = current_node->vptr->SetHas_Left(current_node, 1);
  ntb = x_111;
  x_112 = current_node->vptr->SetLeft(current_node, new_node);
  ntb = x_112;

  goto L_31;
L_29:
  x_113 = current_node->vptr->GetLeft(current_node);
  current_node = x_113;
  goto L_31;
L_31:

  goto L_25;
L_25:

  goto L_20;
L_22:
  return 1;
}
int Tree_Delete(struct Tree * this, int v_key)
{
  struct Tree * current_node;
  struct Tree * parent_node;
  int cont;
  int found;
  int is_root;
  int key_aux;
  int ntb;
  struct Tree * x_30;
  struct Tree * x_31;
  struct Tree * x_32;
  struct Tree * x_33;
  struct Tree * x_34;
  struct Tree * x_35;
  struct Tree * x_36;
  struct Tree * x_37;
  struct Tree * x_38;
  int x_114;
  int x_115;
  int x_116;
  int x_117;
  int x_118;
  int x_119;
  int x_120;
  int x_121;
  int x_122;
  int x_123;
  int x_124;
  struct Tree * x_125;
  int x_126;
  struct Tree * x_127;

L_32:
  current_node = this;
  parent_node = this;
  cont = 1;
  found = 0;
  is_root = 1;
  goto L_33;
L_33:
  if (cont)
    goto L_34;
  else
    goto L_35;
L_34:
  x_114 = current_node->vptr->GetKey(current_node);
  key_aux = x_114;
  x_115 = v_key < key_aux;
  if (x_115)
    goto L_36;
  else
    goto L_37;
L_37:
  x_116 = key_aux < v_key;
  if (x_116)
    goto L_39;
  else
    goto L_40;
L_40:
  if (is_root)
    goto L_42;
  else
    goto L_43;
L_43:
  x_117 = this->vptr->Remove(this, parent_node, current_node);
  ntb = x_117;
  goto L_44;
L_42:
  x_120 = current_node->vptr->GetHas_Right(current_node);
  x_119 = !(x_120);
  x_122 = current_node->vptr->GetHas_Left(current_node);
  x_121 = !(x_122);
  x_118 = x_119 && x_121;
  if (x_118)
    goto L_45;
  else
    goto L_46;
L_46:
  x_123 = this->vptr->Remove(this, parent_node, current_node);
  ntb = x_123;
  goto L_47;
L_45:
  ntb = 1;
  goto L_47;
L_47:
  goto L_44;
L_44:
  found = 1;
  cont = 0;

  goto L_41;
L_39:
  x_124 = current_node->vptr->GetHas_Right(current_node);
  if (x_124)
    goto L_48;
  else
    goto L_49;
L_49:
  cont = 0;
  goto L_50;
L_48:
  parent_node = current_node;
  x_125 = current_node->vptr->GetRight(current_node);
  current_node = x_125;

  goto L_50;
L_50:
  goto L_41;
L_41:
  goto L_38;
L_36:
  x_126 = current_node->vptr->GetHas_Left(current_node);
  if (x_126)
    goto L_51;
  else
    goto L_52;
L_52:
  cont = 0;
  goto L_53;
L_51:
  parent_node = current_node;
  x_127 = current_node->vptr->GetLeft(current_node);
  current_node = x_127;

  goto L_53;
L_53:
  goto L_38;
L_38:
  is_root = 0;

  goto L_33;
L_35:
  return found;
}
int Tree_Remove(struct Tree * this, struct Tree * p_node, struct Tree * c_node)
{
  int ntb;
  int auxkey1;
  int auxkey2;
  struct Tree * x_39;
  struct Tree * x_40;
  struct Tree * x_41;
  struct Tree * x_42;
  struct Tree * x_43;
  struct Tree * x_44;
  struct Tree * x_45;
  struct Tree * x_46;
  struct Tree * x_47;
  struct Tree * x_48;
  struct Tree * x_49;
  struct Tree * x_50;
  int x_128;
  int x_129;
  int x_130;
  int x_131;
  struct Tree * x_132;
  int x_133;
  int x_134;
  int x_135;
  int x_136;
  int x_137;
  int x_138;
  int x_139;

L_54:
  x_128 = c_node->vptr->GetHas_Left(c_node);
  if (x_128)
    goto L_55;
  else
    goto L_56;
L_56:
  x_129 = c_node->vptr->GetHas_Right(c_node);
  if (x_129)
    goto L_58;
  else
    goto L_59;
L_59:
  x_130 = c_node->vptr->GetKey(c_node);
  auxkey1 = x_130;
  x_132 = p_node->vptr->GetLeft(p_node);
  x_131 = x_132->vptr->GetKey(x_132);
  auxkey2 = x_131;
  x_133 = this->vptr->Compare(this, auxkey1, auxkey2);
  if (x_133)
    goto L_61;
  else
    goto L_62;
L_62:
  x_134 = p_node->vptr->SetRight(p_node, this->my_null);
  ntb = x_134;
  x_135 = p_node->vptr->SetHas_Right(p_node, 0);
  ntb = x_135;

  goto L_63;
L_61:
  x_136 = p_node->vptr->SetLeft(p_node, this->my_null);
  ntb = x_136;
  x_137 = p_node->vptr->SetHas_Left(p_node, 0);
  ntb = x_137;

  goto L_63;
L_63:

  goto L_60;
L_58:
  x_138 = this->vptr->RemoveRight(this, p_node, c_node);
  ntb = x_138;
  goto L_60;
L_60:
  goto L_57;
L_55:
  x_139 = this->vptr->RemoveLeft(this, p_node, c_node);
  ntb = x_139;
  goto L_57;
L_57:
  return 1;
}
int Tree_RemoveRight(struct Tree * this, struct Tree * p_node, struct Tree * c_node)
{
  int ntb;
  struct Tree * x_51;
  struct Tree * x_52;
  struct Tree * x_53;
  struct Tree * x_54;
  struct Tree * x_55;
  struct Tree * x_56;
  struct Tree * x_57;
  int x_140;
  int x_141;
  int x_142;
  struct Tree * x_143;
  struct Tree * x_144;
  int x_145;
  int x_146;

L_64:
  goto L_65;
L_65:
  x_140 = c_node->vptr->GetHas_Right(c_node);
  if (x_140)
    goto L_66;
  else
    goto L_67;
L_66:
  x_143 = c_node->vptr->GetRight(c_node);
  x_142 = x_143->vptr->GetKey(x_143);
  x_141 = c_node->vptr->SetKey(c_node, x_142);
  ntb = x_141;
  p_node = c_node;
  x_144 = c_node->vptr->GetRight(c_node);
  c_node = x_144;

  goto L_65;
L_67:
  x_145 = p_node->vptr->SetRight(p_node, this->my_null);
  ntb = x_145;
  x_146 = p_node->vptr->SetHas_Right(p_node, 0);
  ntb = x_146;
  return 1;
}
int Tree_RemoveLeft(struct Tree * this, struct Tree * p_node, struct Tree * c_node)
{
  int ntb;
  struct Tree * x_58;
  struct Tree * x_59;
  struct Tree * x_60;
  struct Tree * x_61;
  struct Tree * x_62;
  struct Tree * x_63;
  struct Tree * x_64;
  int x_147;
  int x_148;
  int x_149;
  struct Tree * x_150;
  struct Tree * x_151;
  int x_152;
  int x_153;

L_68:
  goto L_69;
L_69:
  x_147 = c_node->vptr->GetHas_Left(c_node);
  if (x_147)
    goto L_70;
  else
    goto L_71;
L_70:
  x_150 = c_node->vptr->GetLeft(c_node);
  x_149 = x_150->vptr->GetKey(x_150);
  x_148 = c_node->vptr->SetKey(c_node, x_149);
  ntb = x_148;
  p_node = c_node;
  x_151 = c_node->vptr->GetLeft(c_node);
  c_node = x_151;

  goto L_69;
L_71:
  x_152 = p_node->vptr->SetLeft(p_node, this->my_null);
  ntb = x_152;
  x_153 = p_node->vptr->SetHas_Left(p_node, 0);
  ntb = x_153;
  return 1;
}
int Tree_Search(struct Tree * this, int v_key)
{
  int cont;
  int ifound;
  struct Tree * current_node;
  int key_aux;
  struct Tree * x_65;
  struct Tree * x_66;
  struct Tree * x_67;
  struct Tree * x_68;
  struct Tree * x_69;
  int x_154;
  int x_155;
  int x_156;
  int x_157;
  struct Tree * x_158;
  int x_159;
  struct Tree * x_160;

L_72:
  current_node = this;
  cont = 1;
  ifound = 0;
  goto L_73;
L_73:
  if (cont)
    goto L_74;
  else
    goto L_75;
L_74:
  x_154 = current_node->vptr->GetKey(current_node);
  key_aux = x_154;
  x_155 = v_key < key_aux;
  if (x_155)
    goto L_76;
  else
    goto L_77;
L_77:
  x_156 = key_aux < v_key;
  if (x_156)
    goto L_79;
  else
    goto L_80;
L_80:
  ifound = 1;
  cont = 0;

  goto L_81;
L_79:
  x_157 = current_node->vptr->GetHas_Right(current_node);
  if (x_157)
    goto L_82;
  else
    goto L_83;
L_83:
  cont = 0;
  goto L_84;
L_82:
  x_158 = current_node->vptr->GetRight(current_node);
  current_node = x_158;
  goto L_84;
L_84:
  goto L_81;
L_81:
  goto L_78;
L_76:
  x_159 = current_node->vptr->GetHas_Left(current_node);
  if (x_159)
    goto L_85;
  else
    goto L_86;
L_86:
  cont = 0;
  goto L_87;
L_85:
  x_160 = current_node->vptr->GetLeft(current_node);
  current_node = x_160;
  goto L_87;
L_87:
  goto L_78;
L_78:

  goto L_73;
L_75:
  return ifound;
}
int Tree_Print(struct Tree * this)
{
  struct Tree * current_node;
  int ntb;
  struct Tree * x_70;
  int x_161;

L_88:
  current_node = this;
  x_161 = this->vptr->RecPrint(this, current_node);
  ntb = x_161;
  return 1;
}
int Tree_RecPrint(struct Tree * this, struct Tree * node)
{
  int ntb;
  struct Tree * x_71;
  struct Tree * x_72;
  struct Tree * x_73;
  struct Tree * x_74;
  struct Tree * x_75;
  struct Tree * x_76;
  struct Tree * x_77;
  int x_162;
  int x_163;
  struct Tree * x_164;
  int x_165;
  int x_166;
  int x_167;
  struct Tree * x_168;

L_89:
  x_162 = node->vptr->GetHas_Left(node);
  if (x_162)
    goto L_90;
  else
    goto L_91;
L_91:
  ntb = 1;
  goto L_92;
L_90:
  x_164 = node->vptr->GetLeft(node);
  x_163 = this->vptr->RecPrint(this, x_164);
  ntb = x_163;

  goto L_92;
L_92:
  x_165 = node->vptr->GetKey(node);
  System_out_println (x_165);
  x_166 = node->vptr->GetHas_Right(node);
  if (x_166)
    goto L_93;
  else
    goto L_94;
L_94:
  ntb = 1;
  goto L_95;
L_93:
  x_168 = node->vptr->GetRight(node);
  x_167 = this->vptr->RecPrint(this, x_168);
  ntb = x_167;

  goto L_95;
L_95:
  return 1;
}

// vtables
struct BinaryTree_vtable BinaryTree_vtable_ = 
{
};

struct BT_vtable BT_vtable_ = 
{
  BT_Start,
};

struct Tree_vtable Tree_vtable_ = 
{
  Tree_Init,
  Tree_SetRight,
  Tree_SetLeft,
  Tree_GetRight,
  Tree_GetLeft,
  Tree_GetKey,
  Tree_SetKey,
  Tree_GetHas_Right,
  Tree_GetHas_Left,
  Tree_SetHas_Left,
  Tree_SetHas_Right,
  Tree_Compare,
  Tree_Insert,
  Tree_Delete,
  Tree_Remove,
  Tree_RemoveRight,
  Tree_RemoveLeft,
  Tree_Search,
  Tree_Print,
  Tree_RecPrint,
};


// main method
int Tiger_main ()
{
  struct BT * x_0;
  int x_169;
  struct BT * x_170;

L_96:
  x_170 = ((struct BT*)(Tiger_new (&BT_vtable_, sizeof(struct BT))));
  x_169 = x_170->vptr->Start(x_170);
  System_out_println (x_169);
  return 0;
}




void *prev;
